{"pageProps":{"quiz":{"folder":"c++","path":"data/c++/c++quiz-de.md","questions":[{"text":"#### Q1. Betrachten Sie diese Funktionsdeklaration von `is_even`, die einen ganzzahligen Wert nimmt und \"wahr\" zurückgibt, wenn das Argument eine gerade Zahl ist, ansonsten \"falsch\". Welche Deklarationen sind korrekt für überladene Versionen dieser Funktion, um auch Gleitkomma- und String-Darstellungen von Zahlen zu unterstützen?\n\n```cpp\nbool is_even(int);\n```\n\n-  A\n\n```cpp\nbool is_even(float f);\nbool is_even(char *str);\n```\n\n-  B\n\n```cpp\nbool is_even(float f);\nbool is_even(char str);\n```\n\n-  C\n\n```cpp\nbool is_even_float(float f);\nbool is_even_str(char *str);\n```\n\n-  D\n\n```cpp\nfloat is_even(float f);\nchar *is_even(char *str);\n```\n\n","options":3,"answer":0},{"text":"#### Q2. Was gibt dieser Code aus?\n\n```cpp\nint c=3; char d='A';\nstd::printf(\"c is %d and d is %c\",c,d);\n```\n\n-  c is d and d is c\n-  c is A and d is 3\n-  c is 3 and d is A\n-  c is c and d is d\n\n","options":3,"answer":2},{"text":"#### Q3. Welcher ternäre Operator entspricht diesem Codestück?\n\n```cpp\nif(x)\n    y=a;\nelse\n    y=b;\n```\n\n-  `y=a?b:x;`\n-  `y=if(x?a:b);`\n-  `y=(x&a)?a:(x&b)?b:0;`\n-  `y=x?a:b;`\n\n","options":3,"answer":3},{"text":"#### Q4. Warum ist diese Codezeile schlechter Programmierstil?\n\n`using namespace std;`\n\n-  Wenn der Code eine Funktion aufruft, die in zwei verschiedenen Bibliotheken mit demselben Prototypen, aber womöglich unterschiedlichen Implementierungen definiert ist, tritt wegen Mehrdeutigkeit ein Kompilierfehler auf.\n-  Sie bindet automatisch alle Headerdateien in die Standardbibliothek ein (cstdint, cstdlib, cstdio, iostream usw.).\n-  Sie veranlasst den Compiler dazu zu erzwingen, dass ausschließlich Headerdateien aus der Standardbibliothek eingebunden werden, und führt zu Kompilierfehlern, wenn eine andere Headerdatei eingebunden wird.\n-  Der kopilierte Code ist wegen all der importierten Symbole immer größer.\n\n","options":3,"answer":-1},{"text":"#### Q5. Welche Aktion führt der Operator ^ aus?\n\n-  Er berechnet das bitweise xor zwischen seinen Operanden.\n-  Er berechnet das logische xor zwischen seinen Operanden.\n-  Er nimmt die linke Seite des Operators hoch der Potenz auf der rechten Seite des Operators.\n-  Er tut zweierlei: Er deklariert einen Zeiger und dereferenziert einen Zeiger.\n\n","options":3,"answer":-1},{"text":"#### Q6. Welchen Speicher belegt u1?\n\n```cpp\nunion {\n    unit16_t a;\n    unit32_t b;\n    int8_t c;\n} u1;\n```\n\n-  4 Bytes\n-  7 Bytes\n-  8 Bytes\n-  2 Bytes\n\n[Referenz](https://en.cppreference.com/w/cpp/language/union)\n\n","options":3,"answer":0},{"text":"#### Q7. Was gibt dieses Programm aus?\n\n```\n#include <iostream>\nchar str[20]=\"Hi, there!\";\nint main(){\n    char *p=&str[4];\n    std::count<<*p++;\n    std::count<<p;\n    return 0;\n    }\n```\n\n-  tthere!\n-  uhere!\n-  there!\n-  tuhere!\n\n","options":3,"answer":-1},{"text":"#### Q8. Wie könnte eine gültige Überladung für den ternären Bedingungsoperator erreicht werden?\n\n-  void\\* operator conditional(const bool cond, const void& iftrue, const void& iffalse);\n-  void& operator ?:(const bool cond, const void& iftrue, const void& iffalse);\n-  Der ternäre Operator kann nicht überladen werden.\n-  void* operator ?:(const bool cond, const void* iftrue, const void\\* iffalse);\n\n","options":3,"answer":2},{"text":"#### Q9. Welche Option zeigt den Inhalt der Vektoren, auf die v1 und v2 zeigen, nach der Ausführung dieses Codes?\n\n```cpp\nstd:: vector<int> *v1 = new std::vector<int>({1,2,3});\nstd:: vector<int> *v2;\nv2=v1;\nv1->push_back(4);\nv2->push_back(5);\n```\n\n-  `*v1:{1,2,3,4}; *v2:{5};`\n-  `*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`\n-  Error\n-  `*v1:{1,2,3,4}; *v2:{1,2,3,5};`\n\nv1 und v2 zeigen auf denselben Vektor.\n\n","options":3,"answer":1},{"text":"#### Q10. Wie rufen Sie korrekt die Mitgliedfunktion count für den Objektzeiger grades auf?\n\n```cpp\nclass my_array{\n    public:\n        int count();\n};  // ... weitere Member darüber\n\nint main(){\n    my_array *grades = new my_array();\n};  // ... weitere Code darüber\n```\n\n-  `grades.count();`\n-  `my_array->count();`\n-  `grades->count();`\n-  `my_array.count();`\n\n","options":3,"answer":2},{"text":"#### Q11. Was ist der Zweck eines Konstrukteurs?\n\n-  Damit kann beim Programmieren der nötige Code geschrieben werden, um die vom Objekt belegten Ressourcen freizugeben, bevor das Objekt selbst gelöscht wird.\n-  Er löscht ein Object. Ein Beispiel eines Zerstörers ist die Funktion `delete()`\n-  Er beendet ein Programm. Das kann mit einem regulären Funktionsaufruf oder mit einer Ausnahme erreichen werden.\n-  Es gibt keine Zerstörer in C++.\n\n","options":3,"answer":0},{"text":"#### Q12. Was ist eine geeignete Weise, um `my_object` wie unten gezeigt zu entfernen?\n\n```cpp\nmy_class *my_object = new my_class();\n```\n\n-  `delete(my_object);`\n-  `free(my_object);`\n-  Der Speicherbereiniger wird das Object irgendwann zerstören.\n-  Das Object wird zerstört, wenn der Gültigkeitsbereich verlassen wird.\n\n","options":3,"answer":0},{"text":"#### Q13. Warum ist es nicht möglich, ein Array von Verweisen, einen Zeiger auf einen Verweis oder einen Verweis auf einen Verweis zu deklarieren?\n\n-  Verweise sind Zeiger und keiner der genannten Typen ist für Zeiger sinnvoll.\n-  Tatsächlich ist das möglich, aber diese Typen müssen bei der Deklaration als `const` oder `volatile` spezifiziert werden.\n-  Verweise sind weder Objekte noch Variablen, daher ist nicht garantiert, dass sie Speicher belegen und eine Adresse haben.\n-  Verweise müssen initialisiert werden, damit sie bei der Deklaration auf ein gültiges Objekt oder eine gültige Funktion verweisen.\n\n","options":3,"answer":-1},{"text":"#### Q14. Welche Aussage über die Variable `ptr` ist wahr?\n\n```cpp\nvoid *ptr;\n```\n\n-  Sie ist ein mit NULL initialisierter Zeiger.\n-  Sie ist ein Zeiger auf eine Void-Funktion.\n-  Diese Deklaration verursacht einen Kompilierfehler, weil Zeiger immer einen Typ angeben müssen.\n-  Da sie ein Zeiger auf einen Wert ohne spezifischen Typ ist, kann sie per Typumwandlung als Zeiger auf jeden Typ genutzt werden.\n\n","options":3,"answer":3},{"text":"#### Q15. Wie kann C++-Code eine C-Funktion aufrufen?\n\n-  durch Verwendung von extern \"C\"\n-  indem er den C-Quellcode importiert\n-  Es gibt keine Möglichkeit, mit C++ eine C-Funktion aufzurufen.\n-  indem er einfach den C-Code aufruft\n\n","options":3,"answer":-1}],"title":"## C++"},"lang":"de","availableLanguages":[{"isSelected":true,"name":"Deutsch","key":"de"},{"isSelected":false,"name":"English","key":"en"}]},"__N_SSG":true}